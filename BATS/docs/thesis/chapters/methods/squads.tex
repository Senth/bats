% !TEX root = ../../main.tex
\section{Squads}
A squad in this sense is units grouped together that act together, like a squad in real battle. All squads have the Squad class as their base class. 

\paragraph{Creating, deleting, and retrieving squads}
The squad manager class handles all existing squads, new squads are all automatically inserted into the squad manager (via the squad's constructor). Squad manager stores all squads as \texttt{shared\_ptr} type, meaning they are automatically destroyed when no more references exist. When a squad holds no units—achieved when units die, move to another squad, or squad is disbanded—it is automatically deleted from the squad manager, but can still be found if another class saved it before deletion, this class needs to manually delete the squad. Squad that have been deleted from the squad manager cannot be inserted into the squad manager again, but have to be recreated; therefore it's good to retrieve the squad from the SquadManager in the first place, although it is a bit slower.

Squads can be retrieved using two options, either by the squad's id (automatically set) or by squad type (template function), shown in listing \ref{lst:SquadManager::getSquads()}. The template function will also return all sub-classes to the specified class, meaning \texttt{getSquads<AttackSquad>();} would return both attack squads and drop squads because drop squad is derived from attack squad.
\begin{lstlisting}[caption={Template function to retrieve squads of the specified type.},label={lst:SquadManager::getSquads()}]
template <typename T>
vector<shared_ptr<T>> SquadManager::getSquads();
\end{lstlisting}

\subsection{The squad base class}
There are many features in the squad class, where most of them are helper functions, but only core features are explained in the text. If the reader wants more information, s/he can look in Appendix \ref{sec:doxygen}. First squad movement will be covered, then the squad's basic behaviors, which can be overridden by derived classes. Finally how the \texttt{update()} and \texttt{updateDerived()} functions work.

\paragraph{Squad movement}
This is not how the squad moves, but where the squad's units move to. The potential field manager takes care of how units move and was already implemented in BTHAI—although some changes have been made to the potential field manager to accept some general squad behavior. The squad has five prioritized locations it can move to. Starting from the lowest priority is
\begin{enumerate}
	\item the goal location where the squad want to go to do their main task (e.g. scout, attack, defend position);
	\item while it's good to go there we always want to be able to retreat from an attack or anything else, this is where the retreat position comes into play, only derived squads can set this and \texttt{onRetreatCompleted()} is called when the retreat has succeeded or failed;
	\item to move to either the goal location or retreat location we can use a via path with multiple locations, this is useful when retreating with a drop because otherwise the drop might run straight through the enemy location if not retreating the same way it came from;
	\item a temporary goal location, this when derived classes need an additional goal location, such as \nameref{sec:attack_squad}s waiting in a position to attack or \nameref{sec:hold_squad}s moving from their roaming area to the defended area when an enemy enters the defend perimeter. The temporary goal location is, however, disabled when a retreat position is active; and
	\item a regroup location, the regroup is automatically handled by the squad when units are too spread out—a unit is further away than \squadRegroupDistanceBegin from the squad's center, the regroup stops again when all units are within \squadRegroupDistanceEnd. Currently the regroup position will be set to the center of the squad, this is not ideal but works for now. Bugs occur when the squad is shaped as a C moving outside of a cliff, water, or space, the new regroup position will then be on top of the cliff which ground units might not have access to, whichever the case it can cause undesired behaviors, a better behavior would probably be to use one of the first units location for the regroup. The regroup functionality can be disabled by derived classes, useful when sending reinforcements 
\end{enumerate}

\paragraph{Behaviors}
The squad has four elements that can change the behavior of the squad.
\begin{itemize}
	\item \emph{Regrouping}, which has been fully described above in squad movement.
	\item \emph{Retreating}. While the base class squad never uses this directly, derived classes can set a retreat position and the squad will then check when it is close to the retreat position. Once close it will call \texttt{onRetreatCompleted()} which has the default behavior of disbanding the squad, thus merging it with the Patrol squad. By overriding this function another behavior could be accomplished. Most common for all retreat positions it to get if from the \nameref{sec:defense_manager} via the \texttt{findRetreatPosition()}, if a squad uses another location this will be mentioned.
	\item A squad can contain a \emph{unit composition}, this limits the squad to only contain units of the specific type, useful when creating special type of squads. Section \ref{sec:unit_composition} describes unit composition in more detail.
	\item Some squads usually don't want to get close to enemies, in this case \emph{avoid enemies} can be turned on. This causes attacking units to move to a specific position without attacking (even if they walk straight through enemies); this is due to potential field manager in BTHAI did not support this behavior entirely, thus a simpler version that just uses regular path finding is used due to lack of time to change the potential field algorithm in the manager.
	\item \emph{Wait goals} has been briefly described before in section \ref{sec:attack_coordinator} \nameref{sec:attack_coordinator} and is fully described in section \ref{sec:wait_goals} \nameref{sec:wait_goals}. While adding these does not give the basic squad any specific behavior (yet), they can be used in the derived classes for certain behaviors.
\end{itemize}

\subsection{Attack squad}
\label{sec:attack_squad}
The attack squad is the base class for all offensive squads—in the current version only drops are derived. If not derived, the squad will functions as a regular attack—a regular attack or battle will in this section be synonym for an attack or battle where it is not following an \nameref{sec:allied squad} respectively—if it is not ordered to follow an allied squad. For any attack the squad requests an attack from \nameref{sec:attack_coordinator} to get a position to attack, or if an allied squad is out of home, it will start following it instead.

If it gets a regular attack, it tries to move to the goal position and when it is close to the goal (\squadAttackWaitingPositionDistanceFromGoal) it will stop and wait for its wait goals to finish—i.e. to sync the attack with other attack squads. If it encounters any enemies on the road it will try to kill them, unless they are too strong where the squad will start to retreat instead; the squad can decide to retreat from any regular battle at any time, depending on the situation; retreats are covered later in this section. When all squads are in position, or if any of the squads get spotted and are attacking the other squads start to initiate their attack. They will now continue to move to the goal location. To complete their mission they need to kill all structures near (\squadAttackStructuresDestroyedGoalDistance) the goal position. After it has finished its goal the squad will retreat and then disband the squad, merging with the \nameref{sec:patrol_squad}.

\paragraph{Following an allied squad}
When the squad follows an allied squad it has a slightly different behavior. Because allied squads can merge (and split) the squad will first check if the allied squad is empty, if it is, it will search for close (\squadAttackFindAlliedSquadDistance) allied squads to follow instead. If no allied squads were found, it will retreat and then disband.

Depending on the allied squads current state, the squad acts a bit differently, how it acts is described below in listing \ref{lst:attack_follow_allied}.

\begin{lstlisting}[caption={Squad actions depending on the allied squad's state.},label={lst:attack_follow_allied}]
switch (mpAlliedSquad->getState()) {
	// Regroup if not close
	case IdleOutsideBase:
		handleAlliedRegrouping();
		setAvoidEnemyUnits(true);
		break;
	
	// Go to allied target position, don't attack
	case Retreating:
		if (isRegroupingWithAllied()) {
			clearAlliedRegrouping();
		}
		setGoalPosition(mpAlliedSquad->getTargetPosition());
		setAvoidEnemyUnits(true);
		break;

	// Go to target position, attack if see anything
	case MovingToAttack: 
		if (isRegroupingWithAllied()) {
			clearAlliedRegrouping();
		}
		setGoalPosition(mpAlliedSquad->getTargetPosition());
		setAvoidEnemyUnits(false);
		break;

	// Find something close to attack
	case Attacking:
		handleAlliedRegrouping();
		if (!isRegroupingWithAllied()) {
			setAvoidEnemies(false);
			mpsAttackCoordinator->requestAttack(this);
		}
		break;

	// Retreat, then merge with Patrol Squad (disband)
	case IdleInBase:
		setRetreatPosition(mpsDefenseManager->findRetreatPosition());
		mpAlliedSquad.reset();
		break;
}
\end{lstlisting}
While most of the code speaks for itself, some functions need extra clarification. \texttt{handleAlliedRegrouping()} checks if the distance to the allied squad becomes to large (\squadAttackAlliedRegroupBegin), it both sets the regrouping position to the allied's center position and the squad to avoid enemy units—the regrouping is considered done when the distance between the squads are less or equal to \squadAttackAlliedRegroupEnd away. \texttt{setGoalPosition(mpAlliedSquad->getTargetPosition())} sets the squad to move to the position where most of the allied squad's units are moving to. When using this in the state MovingToAttack, it will effectively regroup with allied squad and not try to chase after it as it would if handleAlliedRegrouping() was used instead. This also allows the allied player to control where the bot shall attack as it will attack where the player decides to attack.

\texttt{mpsAttackCoordinator->requestAttack(this)} uses \nameref{sec:attack_coordinator} to find a place to attack; as mentioned in section \ref{sec:attack_coordinator} it will find an attack position close to the allied squad's target. Why not use the target as with MovingToAttack and have the AttackSquad create the attack position? Because
\begin{inparaenum}[1\upshape)]
	\item we want all attack request to be in the same location, if the attacks needs to be fixed or better coordinated we only need to change it in one place;
	\item in the future the squad could get a location of a prioritized building to attack; and
	\item using allied target directly it will cause our units to fight exactly where the player is, which might crowd the place not making all units able to fight, but would be better if squads are smaller.
\end{inparaenum}

\subsection{Drop squad}
\label{sec:drop_squad}
The drop squad uses attack squad as its base class. Listing \ref{lst:drop_squad} shows the behavior of the squad.
\begin{lstlisting}[caption={Drop squad behavior.},label={lst:drop_squad}]
switch(mState) {
case LoadUnits:
	if (isTransportDoneLoading()) {
		setState(Transport);
	}
	// Note, no break!

case Transport:
	// travelsByGround() = cannot load all units
	if (travelsByGround() && !isRetreating()) {
		setState(Attack);
	} else if (isEnemyAttackUnitsWithinSight()) {
		if (isEnemyFasterThanTransport()) {
			setState(Attack);
	} else {
		if (!hasWaitGoals() && isTransportInGoalRegion()) {
			setState(Attack);
		}
	}
	break;

case Attack:
	// If we cannot load all units, don't load
	if (travelsByGround()) {
		break;
	}

	// Retreat when enemy units arrive, unless they are faster than us
	if (isEnemyAttackUnitsWithingSight()) {
		if (!isEnemyFasterThanTransport()) {
			setState(LoadUnits);
		}
	}
	// No enemies within sight, load if we aren't in the goal region
	else {
		if (!isTransportInGoalRegion()) {
			setState(LoadUnits);
		}
	}
	break;
}
\end{lstlisting}
You might question why not merge the state LoadUnits and Transport as this code would mean no real difference? Because there is more than meets the eye to setState() works differently for each state, \texttt{setState(LoadUnits)} sets the transportation unit to load units and disables regrouping; \texttt{setState(Transport)} enables regrouping again; and \texttt{setState(Attack)} sets the transportation to unload all units and regrouping is enabled.

But how does the drop squad know if its goal has completed? Just as attack squad, it checks if all enemy structures close to the target is done. But as the goal of the drop is not to destroy all buildings, merely to distract the enemy, it also has a timeout function which will make the drop retreat after \squadDropAttackTimeout, but only if it's not currently in the target region.

Now you know how it works, but which units will be used for the drop, as drops should not just use random units and hope for the best? It uses \nameref{sec:unit_composition}s for this—section \ref{sec:unit_composition} describes the unit composition. 

%: Write which drops are available in the current version of BATS

\paragraph{Squad movement}
The target location to drop is, as mentioned, required by the attack coordinator, but the transport does not move in a direct path to the location (once the units are loaded), instead it will move along the edge of the map, illustrated in figure \ref{fig:drop_squad_movement}.
\begin{figure}[htb]
%: Insert image of drop movement path
%: Add color to the caption
\caption[Drop squad movement]{Drop squad movement. GREEN The starting location of the drop. BLUE Path to the drop target. ORANGE Where the squad waits, if it has wait goals. YELLOW where the squad starts to unload. RED target location.}
\label{fig:drop_squad_movement}
\end{figure}

\subsection{Patrol squad}
\label{sec:patrol_squad}
Patrols units between a set of locations, in the current version of BATS it only patrols between our defend positions which the \nameref{sec:defense_manager} handles. The units in the squad automatically attacks close enemies, but all units will not go to that location; instead another manager needs to tell the defensive squad what to do, e.g. the defense manager will tell the squad where to defend. The squad will move to the defended area and attack all units within the defend perimeter (\squadDefendDefendPerimeter), but will remain in the defended area until no enemy units are within the enemy offensive perimeter (\squadDefendEnemyOffensivePerimeter).

The patrol squad will never succeed with its goal, as the goal is to patrol between the specified locations for all the game— although the locations can changed during the game.

%: Write about patrol movement, when no more features are being implemented.

\subsection{Hold squad}
\label{sec:hold_squad}
The hold squad has one goal, to hold a position from enemies; any position could be hold, but it is designed to hold choke points. The squad contains a hold position and a roam position. The hold position works in more or less the same way as patrol squad's defense position, i.e. if enemy units enter the defend perimeter (\squadDefendDefendPerimeter~in radius) it will move and attack those units, as the squad always will defend here it does not bother checking if enemies are within the enemy offensive perimeter as the patrol squad does. The roam position, or rather perimeter (\squadDefendRoamPerimeter~in radius), is where the units in the squad will move to and stay until any enemy units move within the defensive perimeter.

Terran siege tanks have a special ability when in this squad, and the bot has researched the siege tank ability. The siege tank will automatically siege up in the roaming area effectively defending the hold perimeter (and other close positions) from its position.

Hold squads use \nameref{sec:unit_composition}s to know which units should be in the hold squad—section \ref{sec:unit_composition} describes the unit composition and lists the configuration file for hold squad in listing \ref{lst:unit_composition_defense}. The current unit compositions used by BATS are listed below; the top is the composition with least priority, whereas the bottom is the one with highest priority. The name of the composition is in bold text.

\begin{enumerate}
	\item \textbf{Marine spotter}~1 Marine.
	\item \textbf{Marine Medics}~4 Marines, 1 Medic.
	\item \textbf{Tanks 1}~1 Siege tank.
	\item \textbf{Tanks 2}~2 Siege tanks.
\end{enumerate}
The Marine spotter is used to watch for enemies as one marine alone is not a good defender. Marines and medics generally make a good composition, but these number are too low to hold of almost any attack, but they can still delay the attack until reinforcements can arrive. Tanks are very good positional holders and can hold of almost anything coming from the choke point. 

As the marine auto-bunker feature has not been enable yet another composition could be made with only for marines, but this group would be very vulnerable if the bunker was not present and there is no such feature in unit composition yet, i.e. to set a requirement for the composition, such as target position needs to have a bunker.

\subsection{Scout squad}
\label{sec:scout_squad}
The scout squad scouts regions and expansions that have not been scouted for a long time, to be exact it will always go the region or expansion that was the longest time anyone from our team visited it. The \nameref{sec:exploration_manager} that handles this and thus the scout squad gets it target location from it. To avoid multiple scouts moving to the same location the scout location will reset its last visit time when the squad gets the location, although it hasn't been visited at all.

When an enemy is seen the scout will abandon its current scout location and find another one, the idea is not to suicide in to the enemy but keep it alive at all times. This, however, does not currently work as good as the unit doesn't avoid the enemy and must be lucky to get the other scout location in the right direction first. While the potential field manager has an avoid enemy functionality implemented this did not work very well with the retreat functionality 

This feature can be added in potential field manager to use potential fields when fleeing from an enemy. 

Limitations with the current version of the scout. Although another unit might visit the target location the squad will not complete its goal until it has reached there itself. The second limitation is that the scout path is not optimal, thus it can move from one end of the map to the other (already passing recently scouted areas), an improvement would be to either let the squad get regions and expansions that abut to its current location, or search for the most optimal path (in regard to visit not-recently visited locations) when moving to the target location—i.e. use its via path. The first option is probably preferable as it is easy to calculate and easy to check if the first limitation should be solved, otherwise one must check all via paths and the path might not be the optimal anymore if one location is removed.

\subsection{Unit composition}
\label{sec:unit_composition}
In a nutshell, the unit composition is a feature for the squads to require specific types of units. E.g. hold squads require specific unit groups (compositions) as was explained above in section \ref{sec:hold_squad}. Below in listing \ref{lst:unit_composition_defense} the unit composition file for the hold squad is listed.

\begin{lstlisting}[caption={Hold squad unit compositions},label={lst:unit_composition_defense},language=ini]
; ---------- Marine Spotter ----------
[marine_spotter]
Priority = 1

[marine_spotter.units]
Terran_Marine = 1

; ---------- Bunker Marines ----------
[bunker_marines]
Priority = 2

[bunker_marines.units]
Terran_Marine = 4

; ---------- Marine Medics ----------
[marine_medics]
Priority = 3

[marine_medics.units]
Terran_Marine = 4
Terran_Medic = 1

; ---------- 1 Tank ----------
[tanks_1]
Priority = 4

[tanks_1.units]
Terran_Siege_Tank_Siege_Mode = 1

; ---------- 2 Tanks ----------
[tanks_2]
Priority = 5

[tanks_2.units]
Terran_Siege_Tank_Siege_Mode = 2
\end{lstlisting}
The unit composition has two important elements: The priority and the units, higher value means higher priority, the units for the composition are listed under the units sub-section.

To use compositions one calls the unit composition factory which takes a type (hold-squad, drop, etc.) of composition and a list of units (usually free units). The unit composition factory will check which compositions can be created with the available units—the composition needs to be full—and then return these sorted by priority. It is then up to the caller of unit composition factory to decide which composition to use—for hold squads it will always use the one with highest priority, drops on the other hand takes one random at the time of writing.

\subsection{Wait goals}
\label{sec:wait_goals}
Wait goals were created for simple trigger abilities, although to function fully as independent trigger some rework needs to be done as they do not send any events and are not repeatable. These can be added to any squad at the moment, but will only have any effect if the derived squad handles them in any way, as the attack squad does. Wait goals are added to the wait goal manager which updates the goals to check if they have succeeded, failed, or timed out.

Wait goals can be added to a set type, this allows all wait goals with the same set type to be easily extracted—attack coordinator uses this when adding existing wait goals to a new attack squad.